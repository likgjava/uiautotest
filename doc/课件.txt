

移动自动化测试
1.1移动自动化测试简介
随着互联网技术的飞速发展，软件行业也变得越来越发达。使用软件的用户和软件的使用频率也在不断增多，所以对软件质量的要求也随之提高。考虑到成本、效率等因素，企业目前对自动化测试的重视度越来越高。软件测试这个行业都走向了自动化这条路，对于现在的我们来说自动化测试是我们必须掌握的技能，同时它也是这个行业的一种发展趋势。自动化测试是一个接近测试开发的工作。


1.2移动自动化测试工具有哪些？
1、MonkeyRunner是Android SDK提供的测试工具。该工具提供了一些API，可以通过该API来控制Android设备或者模拟器。
2、UiAutomator也是Android提供的自动化测试框架，基本上支持所有的Android事件操作，对比Instrumentation它不需要测试人员了解代码实现细节。基于Java，测试代码结构简单、编写容易、学习成本，一次编译，所有设备或模拟器都能运行测试，能跨App。Uiautomator是Android 4.1后加入的，所以仅支持Android 4.1 和以上的版本，但是不支持webview。
3、Robotium也是基于Instrumentation的测试框架，只支持Java语言开发并只支持Android，并不支持跨进程。
4、Espresso是Google的开源自动化测试框架。相对于Robotium和UIAutomator，它的特点是规模更小、更简洁，API更加精确，编写测试代码简单，容易快速上手。因为是基于Instrumentation的，所以不能跨App。
5、Appium是最近比较热门的框架，社区也很活跃，功能很强大。

1.3Appium介绍
特点：
开源；
支持Native App、Hybird App、Web App；
支持Android、iOS、Firefox OS；
Server也是跨平台的，你可以使用Mac OS X、Windows或者Linux；
用Appium自动化测试不需要重新编译App；
支持很多语言来编写测试脚本，Java、Javascript、PHP、Python、C#、Ruby等主流语言；

设计理念：
C/S架构，appium的核心是一个web服务器，它提供了一套REST的接口，他会接收客户端的连接，监听到命令。执行会再将结果通过HTTP响应返还给客户端。
session，每个client连接到server以后都会创建一个session，自动化始终围绕一个session进行。不同语言有不同实现方式，但最终都是发送一个POST请求给服务端，请求中包含一个JSON对象。
Appium Server是Node.js写的，所以可以直接用NPM来进行安装。

相关限制：
如果你在Windows使用Appium，你没法使用预编译专用于OS X的.app文件，因为Appium依赖OS X专用的库来支持iOS测试，所以在Windows平台你不能测试iOS Apps。



1.4论本课程的重要性
面试中的加分项、吹牛逼的资本...




appium环境搭建

1、安装JDK
版本：1.8
下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
配置环境变量：
JAVA_HOME=C:\Program Files\Java\jdk1.7.0_80
在Path中添加:%JAVA_HOME%\bin;

2、安装IDEA
官网：https://www.jetbrains.com/


3、安装Android SDK
下载地址：http://dl.google.com/android/android-sdk_r24.4.1-windows.zip
配置环境变量：
ANDROID_HOME=D:\software\Android\Sdk
在Path中添加:%ANDROID_HOME%\tools;%ANDROID_HOME%\platform-tools;

4、安装Genymotion
1）打开Genymotion官网：https://www.genymotion.com/ 
2）注册
3）下载地址：https://www.genymotion.com/download/
4）VirtualBox下载地址：http://download.virtualbox.org/virtualbox/5.1.30/VirtualBox-5.1.30-118389-Win.exe
注意事项：
1、最好不要改变VirtualBox的安装路径
2、enabled in BIOS settings，开机启动时设置virtualization technology的选项为Enabled。


异常：Failure [INSTALL_FAILED_NO_MATCHING_ABIS]
原因：Genymotion出现这个情况需要安装补丁包。原因是某些应用使用了原生库（NDK，Native Lib）因为这些库的编译目标通常是arm的cpu，在x86上运行就会报这样的错误。
具体解决办法如下：
下载Genymotion-ARM-Translation_v1.1.zip，直接拖入genymotion模拟器窗口，直到提示成功。


异常：Genymotion unfortunately has stopped
genymotion 6.0的 arm 兼容包，拖进去，处理完成后点OK，再关闭模拟器重启一下就可以了。



5、安装appium
appium有两种安装模式:
通过客户端安装
通过终端安装

区别：
在做自动化时，很多时候我们都是连接多台电脑去执行，但是appium去连接多台电脑时就需要启动多个appium的服务，如果说你安装是通过客户端去安装的，你连接多台机器就需要启动多个客户端，这样对你电脑本身也是一个性能考验。如果你是通过终端命令安装的在启动的时候你只需要通过命令启动多个服务就好。

appium客户端安装：
官方下载：http://appium.io/
下载地址：https://github.com/appium/appium-desktop/releases


appium终端安装：
首先安装nodejs，下载地址：https://nodejs.org/en/download/
1）直接在终端输入命令：npm install -g appium 一般不会成功，有防火墙
2）通过国内镜像安装：npm -registry http://registry.cnpmjs.org install -g appium
3）通过cnpm安装：
npm install -g cnpm --registry=https://registry.npm.taobao.org
cnpm install -g appium

npm与cnpm
npm（node package manager）是nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）
1.安装插件：npm install <name> [-g] [--save-dev]
<name>：node插件名称。 
例：npm install appium --save-dev
-g：全局安装。 
将会安装在C:\Users\Administrator\AppData\Roaming\npm，并且写入系统环境变量；非全局安装：将会安装在当前定位目录；全局安装可以通过命令行在任何地方调用它，本地安装将安装在定位目录的node_modules文件夹下，通过require()调用；
--save：将保存配置信息至package.json（package.json是nodejs项目配置文件）；
-dev：保存至package.json的devDependencies节点，不指定-dev将保存至dependencies节点；
2.卸载插件：npm uninstall <name> [-g] [--save-dev] 
PS：不要直接删除本地插件包 
3.更新插件：npm update <name> [-g] [--save-dev] 
4.更新全部插件：npm update [--save-dev] 
5.查看npm帮助：npm help 
6.查看当前目录已安装插件：npm list


说明：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，所以我们乐于分享的淘宝团队干了这事。
官方网址：http://npm.taobao.org
安装：npm install cnpm -g --registry=https://registry.npm.taobao.org
注意：
1.安装完后最好查看其版本号cnpm -v或关闭命令提示符重新打开，安装完直接使用有可能会出现错误
2.cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm。 



7、appium的hello world
示例效果：通过程序自动安装“知乎”APP到手机中，启动APP并模拟左右滑动来切换页面。
//获取屏幕的宽度和高度
int x = driver.manage().window().getSize().getWidth();
int y = driver.manage().window().getSize().getHeight();
System.out.println("x===="+x);
System.out.println("y===="+y);

driver.swipe(x * 9/10, y/2, x/10, y/2, 500);
Thread.sleep(10000);
driver.swipe(x * 9/10, y/2, x/10, y/2, 500);
Thread.sleep(3000);

8、appium日志分析



============================================================================================================================
Android知识讲解
1、ADB工具
简介
ADB的全称为Android Debug Bridge，字面意思就是安卓调试桥接，简单点说就是一个调试工具。它是Android系统提供的一套工具，通过它我们可以在电脑上建立一个连接到手机的通道，然后可以在电脑上向手机发送一些指令，完成一些我们需要做的工作。

ADB常用命令
命令	描述
adb devices	查看已连接的设备
adb install <xxx.apk>	将apk文件安装到设备上
adb -s <serialno> install <xxx.apk>	将apk文件安装到指定设备上
adb uninstall <packageName>	卸载app
adb uninstall -k <packageName>	卸载app，保留数据和缓存
adb -s <serialno> uninstall <packageName>	卸载指定手机上的app
adb push <本地文件> <手机目标文件>	将本地文件上传到手机
adb pull <手机文件> <本地目标文件>	将手机文件下载到本地
adb shell	进入手机控制台
adb shell pm list packages	执行一条Linux命令


2、UIAutomatorViewer工具
UIAutomatorViewer是一个定位工具，在Android SDK目录下的tools/bin目录下。
我们打开定位工具、模拟器后直接点击定位工具左上角红色圈出的按钮（获取当前屏幕）UIAutomatorViewer会自动获取到当前模拟器所打开的页面。
最左边的区域就是捕获的模拟器页面，在该页面鼠标移到你要查找的元素上面，在整个区域右面上面就是当前对象的一个布局结构，能够清晰的看见他是采用的是什么布局。右下角的区域就是我们需要定位的对象的属性值


3、Package及Activity讲解
Package可以理解为APP的命名空间，是APP的唯一标示。我们在做APP自动化时，就需要知道他的Package，通过Package就可以定位到是哪个APP了。

Activity是Android组件中最基本也是最为常见用的四大组件之一。和用户进行交互的，每当用户打开app进行操作的时候会发现在不断的跳页面，其实每个页面就是一个activity。我们做自动化时拿到了这个app的Package，但是我们还不能启动起来，因为我们没有告诉需要去操作哪一个Activity，因此在这个时候我们需要讲app启动时的Activity写入到启动参数中，如果你传入一个其他页面的是不行的。

如何获取package及activity
获取package和activity的方法，在网上说了有很多种，这里我只给大家说我们常用的。
1、询问开发人员
2、使用aapt工具。aapt是sdk自带的一个工具，在sdk\builds-tools\目录下。
1.在命令行输入：aapt dump badging D:/apk/zhihu.apk
2.运行后的结果中以下两行分别是应用包名package和入口activity名称
package: name='com.zhihu.android'
launchable-activity: name='com.zhihu.android.app.ui.activity.MainActivity'

3、

2.日志法
a、启动待测apk
b、开启日志输出：adb logcat>D:/log.txt
c、关闭日志输出：ctrl+c
d、查看日志
直接搜索 ：Displayed
找寻：Displayed com.mm.android.hsy/.ui.LoginActivity: +3s859ms
appPackage = com.mm.android.hsy
appActivity = .ui.LoginActivity

我一直用的方法是：
adb shell
logcat | grep cmp=

自己用的简洁版：

adb logcat|find "Displayed" >d:/logs.txt

adb logcat|findstr /I "\.*activity" 



============================================================================================================================

学习DesiredCapabilities
简介
DesiredCapabilities 携带了一些配置信息，在启动session的时候是必须提供，如启动模式、apk/app配置、package/activity配置、浏览器配置、键盘配置等。
DesiredCapabilities的重要作用是在启动时传递信息给Appium Server。

常用Capability配置

下表中列举了Appium常用的Capability配置


============================================================================================================================

元素定位

name：name可以用text或content-desc只要这两个属性，任意一个有内容都可以用他定位。不要用name定位输入框，比如输入框中有默认值，每次输入内容后值都会改变，这时再次定位就会定位不到了。
driver.findElement(By.name("每日推荐"));
driver.findElementByName("每日推荐");

className：这个定位在web时可以，手机中同名的className太多了。
driver.findElement(By.className("android.widget.TextView"));
driver.findElementByClassName("android.widget.TextView");

id：redouce-id中的内容
driver.findElement(By.id("com.miui.home:id/search_but"));
driver.findElementById("com.miui.home:id/search_but");

AccessibilityId
driver.findElementByAccessibilityId("今日头条");

UiAutomator
driver.findElementByAndroidUIAutomator("new UiSelector().text(\"每日推荐\")");

xpath
driver.findElement(By.xpath("android.widget.FrameLayout[contains(@name, '每日推荐')]"));
driver.findElementByXpath("android.widget.FrameLayout[contains(@name, '每日推荐')]");


============================================================================================================================

元素点击
1).单击
单击方式有四个。下面分别写个示例，如何定位就不写了，常见的点击是click()方法，不过手机最好用TouchAction来点击。
element.click();
element.tap(1, 300);
driver.tap(1, element, 300);
new TouchAction(driver).tap(element).release().perform();


2).多击
element.tap(2, 30);
driver.tap(2, element, 30);
new TouchAction(driver).press(element).waitAction(30).release().press(element).waitAction(30).release().perform();


3).长按
new TouchAction(driver).longPress(element).release().perform();
new TouchAction(driver).longPress(element, 100).release().perform();

--------------------------------------------------------------
输入框操作
element.sendKeys("1234中国");
driver.pressKeyCode(AndroidKeyCode.KEYCODE_A); // 字母“a”
driver.pressKeyCode(AndroidKeyCode.DEL);


--------------------------------------------------------------

滑动
1.页面滑动
手机坐标原理图：

滑动时开始位置和结束位置要在屏幕内，不能超出屏幕，但手机分不同分辨率，我们的代码就得兼容不同分辨率的手机，因此我们首先要获得手机分辨率，才能确定我们手指的位置。手指的位置不要离屏幕边缘太近。
获取屏幕分辨率
Dimension dimension = driver.manage().window().getSize();

获取X轴最大值和Y轴最大值。
int x = dimension.getWidth();
int y = dimension.getHeight();

滑动屏幕在appium中使用到的方法是：
driver.swipe(int startx, int starty, int endx, int endy, int duration);

这时我们需要考虑滑屏的开始位置和结束位置，


通过上图，我们可以知道，左右滑动时Y轴不变，上下滑动时，X轴不变。那么我们就可以将不变值定为屏幕中间的位置，即x / 2或 y / 2.
滑动的区间可以设置为从9/10的位置滑到1/10的位置。通过计算最终可适用全部手机。duration表示滑动时间，毫秒，数值越小滑动越快。
从上往下滑动
driver.swipe(x/2, y/10, x/2, y*9/10, 500);
从下往上滑动
driver.swipe(x/2, y*9/10, x/2, y/10, 500);
从左往右滑
driver.swipe(x/10, y/2, x*9/10, y/2, 500);
从右往左滑
driver.swipe(x*9/10, y/2, x/10, y/2, 500);


2.元素滑动
元素滑动其实就是精确位置的页面滑动。首先要获取到元素的开始位置的坐标，再获取到元素的高度和宽度，然后计算出滑动的开始和结束坐标。
//获取元素信息
AndroidElement element = driver.findElement(By.xpath("//android.widget.FrameLayout[@index=2]"));
int x = element.getLocation().getX();
int y = element.getLocation().getY();
int width = element.getSize().getWidth();
int height = element.getSize().getHeight();

//计算起止位置坐标
int startX = x + width * 9 / 10;
int startY = y + height / 2;
int endX = x + width / 10;
int endY = startY;

//从右往左滑
driver.swipe(startX, startY, endX, endY, 500);
Thread.sleep(10000);

3.解锁九宫格
思路：
在做功能测试时，是将手指按住屏幕，然后从一个点滑动到另一个点，将密码滑动完成后再抬起手。这个方法封装在TouchAction中，TouchAction方法所有操作都需要加perform才会执行。

//定位9个圆点
AndroidElement one = driver.findElement(By.name("one"));
AndroidElement two = driver.findElement(By.name("two"));
AndroidElement three = driver.findElement(By.name("three"));
AndroidElement four = driver.findElement(By.name("four"));
AndroidElement five = driver.findElement(By.name("five"));
AndroidElement six = driver.findElement(By.name("six"));
AndroidElement seven = driver.findElement(By.name("seven"));
AndroidElement eight = driver.findElement(By.name("eight"));
AndroidElement nine = driver.findElement(By.name("nine"));
//1->2->5->8->9
TouchAction touchAction = new TouchAction(driver);
touchAction.press(one).moveTo(two).moveTo(five).moveTo(eight).moveTo(nine).release().perform();

--------------------------------------------------------------



下拉框操作

--------------------------------------------------------------
屏幕放大缩小






===================================================================================================================================

TestNG
简介
TestNG是java的一个测试框架，Java中已经有一个JUnit的测试框架，但TestNG比JUnit功能强大的多。JAVA测试人员一般用TestNG来写自动化测试。
TestNG是用来简化广泛的测试需求的测试框架，从单元测试到集成测试。

安装
高版本的IDEA已经绑定了TestNG，不需要安装额外的插件。

TestNG基本注解
注解	描述
@BeforeSuite	被注解的方法只运行一次，运行此套件中所有测试方法前运行
@AfterSuite	被注解的方法只运行一次，运行完此套件的所有测试方法后运行
@BeforeTest	被注解的方法只运行一次，运行在此套件前
@AfterTest	被注解的方法只运行一次，运行在此套件后
@BeforeClass	被注解的方法只运行一次，运行在此套件的类前
@AfterClass	被注解的方法只运行一次，运行在此套件的类后
@BeforeGroups	被注解的方法运行次数与@Groups个数有关，运行在此套件的所有@Groups前
@AfterGroups	被注解的方法运行次数与@Groups个数有关，运行在此套件的所有@Groups后
@BeforeMethod	被注解的方法运行次数与@Test个数有关，在运行@Test前运行，如果有n个@Test则运行n次
@AfterMethod	被注解的方法运行次数与@Test个数有关，在运行@Test后运行，如果有n个@Test则运行n次
@DataProvider	为一个方法提供数据，必须返回Object[][]，如果一个方法想获取数据，使用dataProvider结束数据
@Factory	作为一个工厂，返回TestNG的测试类对象，该方法必须返回Object[]
@Listeners	定义一个测试类的监听器
@Parameters	介绍如何将参赛传递给@Test方法
@Test	测试类或方法


使用方式
忽略测试
如果我们的代码没写好或测试方法无法运行，这时我们需要禁用此方法。
@Test(enabled = false)
public void bar(){
	System.out.println("bar...");
}


异常测试
异常测试需要被注解的测试方法能够抛出异常，否则执行失败
@Test(expectedExceptions = ArithmeticException.class)
public void divByZeroTest() {
	int count = this.div(10, 0);
	System.out.println("count=" + count);
}
public int div(int a, int b) {
	return a / b;
}

依赖测试
有时测试方法有先后顺序，这时后执行的方法就需要依赖先执行的方法了
public class DependTest {
    @Test
    public void openApp() {
        System.out.println("openApp...");
    }

    @Test(dependsOnMethods = "openApp")
    public void inputUsername() {
        System.out.println("inputUsername...");
    }

    @Test(dependsOnMethods = "inputUsername")
    public void login() {
        System.out.println("login...");
    }
}

参数化
1.注解方式
public class DataProviderTest {
    @DataProvider
    public Object[][] userData() {
        return new Object[][]{new Object[]{1, "tom"}, new Object[]{2, "lucy"}};
    }

    @Test(dataProvider = "userData")
    public void printUserList(int userId, String username) {
        System.out.println("userId=" + userId + "\tusername=" + username);
    }
}

2.读取XML中的参数
public class XmlParameterTest {
    @Test
    @Parameters("username")
    public void test(String name) {
        System.out.println("username=" + name);
    }
}

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd">
<suite name="suite">
    <test name="test">
        <parameter name="username" value="tom"/>
        <classes>
            <class name="com.likg.uiautotest.testng.XmlParameterTest"/>
        </classes>
    </test>
</suite>


TestNG套件
TestNG套件是一组测试行为的集合。写在XML中，套件可以包含一个或多个测试。<suite>是根标签，它描述了一个测试套件。

suite属性
参数	说明	参数值	使用方法
name	必选项，此套件的名称	suite名字	name="XXX"
junit	是否执行Junit模式(识别setup()等)	true和false，默认false	junit="true"
verbose	控制台输出的详细内容等级,0-10级（0无，10最详细）	0到10	verbose="5"
parallel	是否在不同的线程并行进行测试，要与thread-count配套使用	详见表格下内容，默认false	parallel="mehods"
configfailurepolicy	测试失败后是再次执行还是跳过，值skip和continue	skip、continue，默认skip	configfailurepolicy="skip"
thread-count	与parallel配套使用，线程池的大小，决定并行线程数量	整数，默认5	thread-count="10"
annotations	获取注解，值为javadoc时，使用JavaDoc的注释；否则用JDK5注释	javadoc	annotations="javadoc"
time-out	设置parallel时，终止执行单元之前的等待时间（毫秒）	整数，单位毫秒	time-out="10000"
skipfailedinvocationcounts	是否跳过失败的调用	true和false，默认false	skipfailedinvocationcounts="true"
data-provider-thread-count	并发时data-provider的线程池数量	整数	data-provider-thread-count="5"
object-factory	一个实现IObjectFactory接口的类，实例化测试对象	类名	object-factory="classname"
allow-return-values	是否允许返回函数值	true和false	all-return-values="true"
preserve-order	是否按照排序执行	true和false，默认true	preserve-order="true"
group-by-instances	按照实例分组	true和false，默认false	group-by-instances="true"


TestNG运行JUnit
TestNG可以运行JUnit测试类，需要把属性junit设置为true。运行JUnit的testng.xml如下
package com.likg.uiautotest.testng;
import org.junit.Test;
/**
 * junit测试类
 * @author likg
 */
public class JunitTest {
    @Test
    public void foo(){
        System.out.println("foo...");
    }
}

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd">
<suite name="suite" junit="true">
    <test name="test">
        <classes>
            <class name="com.likg.uiautotest.testng.JunitTest"/>
        </classes>
    </test>
</suite>


顺序执行
如果有多个@test我们需要给这些test规定执行顺序，那么我们应该这么写testng.xml
public class TestngOrder {
    @Test
    public void one(){
        System.out.println("one...");
    }

    @Test
    public void two(){
        System.out.println("two...");
    }

    @Test
    public void three(){
        System.out.println("three...");
    }

    @Test
    public void four(){
        System.out.println("four...");
    }
}

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd">
<suite name="suite">
    <test name="test">
        <classes>
            <class name="com.likg.uiautotest.testng.TestngOrder">
                <methods>
                    <include name="one" />
                    <include name="two" />
                    <include name="three" />
                    <include name="four" />
                </methods>
            </class>
        </classes>
    </test>
</suite>


组测试
将相似的测试方法合并到一起。组测试要写在testng.xml的<test>或<suite>中
在TestNG中，组groups的概念主要是相对于测试方法而言的。将具有相似功能的测试方法分组，这样在定义测试用例的时候就可以以组为单位加入对应的测试方法。
示例一
public class TestngGroups {
    @Test(groups = {"g1"})
    public void f1() {
        System.err.println("groups=g1 f1...");
    }

    @Test(groups = {"g2"})
    public void f2() {
        System.err.println("groups=g2 f2...");
    }

    @Test(groups = {"g1", "g2"})
    public void f3() {
        System.err.println("groups=g1,g2 f3...");
    }

    @Test(groups = {"g1", "g2"})
    public void f4() {
        System.err.println("groups=g1,g2 f4...");
    }
}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd">
<suite name="suite">
    <test name="TestGroups">
        <groups>
            <run>
                <include name="g1"/>
                <exclude name="g2"/>
            </run>
        </groups>

        <classes>
            <class name="com.likg.uiautotest.testng.TestngGroups"/>
        </classes>
    </test>
</suite>

示例二
public class TestngGroupsOfGroups {
    @Test(groups = {"android.4"})
    public void f1() {
        System.err.println("groups=android.4 f1...");
    }

    @Test(groups = {"android.5"})
    public void f2() {
        System.err.println("groups=android.5 f2...");
    }

    @Test(groups = {"android.5.2"})
    public void f3() {
        System.err.println("groups=android.5.2 f3...");
    }

    @Test(groups = {"android.6"})
    public void f4() {
        System.err.println("groups=android.6 f4...");
    }
}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd">
<suite name="suite">
    <test name="groupsOfGroups">
        <groups>
            <define name="android4">
                <include name="android.4"/>
            </define>
            <define name="android5">
                <include name="android.5"/>
                <include name="android.5.2"/>
            </define>
            <define name="all">
                <include name="android.*"/>
            </define>
            <run>
                <include name="all"/>
                <exclude name="android5"/>
            </run>
        </groups>
        <classes>
            <class name="com.likg.uiautotest.testng.TestngGroupsOfGroups"/>
        </classes>
    </test>
</suite>



断言
断言是预期结果与实际结果之间的比较。可以传递的参数有字符串、数组、数据类型等。下面举几个例子。
public class AssertTest {
    @Test
    public void foo(){
        int sum = this.add(1, 1);
        Assert.assertEquals(sum, 2);
        Assert.assertNotEquals(sum, 3);
        Assert.assertTrue(true);
        Assert.assertFalse(false);
    }

    public int add(int a, int b){
        return a + b;
    }
}


生成测试报告
IEDA中生成测试报告配置
1、点击工具条中Run，选择Edit Configurations，弹出运行配置对话框，在左侧选择要设置运行的test，在右侧选择Configuration的Listeners项，将Listeners中的use Default reporters前的选择框打上对号，然后点击ok。
2、重新运行test，就会生产test-output文件了。



===================================================================================================================================

其他知识点：
横竖屏切换
截图操作









===================================================================================================================================
http://blog.csdn.net/wukuy123/article/details/73744784



问题记录：
Android 怎么获取 INJECT_EVENTS（小米手机）
http://blog.csdn.net/zhaoqi5705/article/details/53455597


cnpm与npm的区别
http://blog.csdn.net/chi1130/article/details/72773278




资源
http://www.cnblogs.com/fnng/p/4540731.html
https://anikikun.gitbooks.io/appium-girls-tutorial/content/download_fulu.html 









